<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>STIMA: kk_ihex</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">STIMA
   &#160;<span id="projectnumber">3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">kk_ihex </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>A small library for reading and writing the <a href="http://en.wikipedia.org/wiki/Intel_HEX">Intel HEX</a> (or IHEX) format. The library is mainly intended for embedded systems and microcontrollers, such as Arduino, AVR, PIC, ARM, STM32, etc - hence the emphasis is on small size rather than features, generality, or error handling.</p>
<p>See the header file <code><a class="el" href="kk__ihex_8h_source.html">kk_ihex.h</a></code> for documentation, or below for simple examples.</p>
<p>~ <a href="https://arkku.com/">Kimmo Kulovesi</a>, 2013-12-27</p>
<h1>Writing </h1>
<p>Basic usage for writing binary data as IHEX ASCII: </p><pre class="fragment">#include "kk_ihex_write.h"

struct ihex_state ihex;
ihex_init(&amp;ihex);
ihex_write_at_address(&amp;ihex, 0);
ihex_write_bytes(&amp;ihex, my_data_bytes, my_data_size);
ihex_end_write(&amp;ihex);
</pre><p> The function <code>ihex_write_bytes</code> may be called multiple times to pass any amount of data at a time.</p>
<p>The actual writing is done by a callback called <code>ihex_flush_buffer</code>, which must be implemented, e.g., as follows: </p><pre class="fragment">void ihex_flush_buffer(struct ihex_state *ihex, char *buffer, char *eptr) {
    *eptr = '\0';
    (void) fputs(buffer, stdout);
}
</pre><p> The length of the buffer can be obtained from <code>eptr - buffer</code>. The actual implementation may of course do with the IHEX data as it pleases, e.g., transmit it over a serial port.</p>
<p>For a complete example, see the included program <code>bin2ihex.c</code>.</p>
<h1>Reading </h1>
<p>Basic usage for reading ASCII IHEX into binary data: </p><pre class="fragment">#include "kk_ihex_read.h"

struct ihex_state ihex;
ihex_begin_read(&amp;ihex);
ihex_read_bytes(&amp;ihex, my_ascii_bytes, my_ascii_length);
ihex_end_read(&amp;ihex);
</pre><p> The function <code>ihex_read_bytes</code> may be called multiple times to pass any amount of data at a time.</p>
<p>The reading functions call the function <code>ihex_data_read</code>, which must be implemented by the caller to store the binary data, e.g., as follows: </p><pre class="fragment">ihex_bool_t ihex_data_read (struct ihex_state *ihex,
                            ihex_record_type_t type,
                            ihex_bool_t checksum_error) {
    if (type == IHEX_DATA_RECORD) {
        unsigned long address = (unsigned long) IHEX_LINEAR_ADDRESS(ihex);
        (void) fseek(outfile, address, SEEK_SET);
        (void) fwrite(ihex-&gt;data, ihex-&gt;length, 1, outfile);
    } else if (type == IHEX_END_OF_FILE_RECORD) {
        (void) fclose(outfile);
    }
    return true;
}
</pre><p> Of course an actual implementation is free to do with the data as it chooses, e.g., burn it on an EEPROM instead of writing it to a file.</p>
<p>For an example complete with error handling, see the included program <code>ihex2bin.c</code>.</p>
<h1>Example Programs </h1>
<p>The included example programs, <code>ihex2bin</code> and <code>bin2ihex</code>, implement a very simple conversion between raw binary data and Intel HEX. Usage by example: </p><pre class="fragment"># Simple conversion from binary to IHEX:
bin2ihex &lt;infile.bin &gt;outfile.hex

# Add an offset to the output addresses (i.e., make the address
# of the first byte of the input other than zero):
bin2ihex -a 0x8000000 -i infile.bin -o outfile.hex

# Encode 64 input bytes per output IHEX line:
bin2ihex -b 64 &lt;infile.bin &gt;outfile.hex

# Simple conversion from IHEX to binary:
ihex2bin &lt;infile.hex &gt;outfile.bin

# Manually specify the initial address written (i.e., subtract
# an offset from the input addresses):
ihex2bin -a 0x8000000 -i infile.hex -o outfile.bin

# Start output at the first data byte (i.e., make the address offset
# equal to the address of the first data byte read from input):
ihex2bin -A -i infile.hex -o outfile.bin
</pre><p> Both programs also accept the option <code>-v</code> to increase verbosity.</p>
<p>When using <code>ihex2bin</code> on Intel HEX files produced by compilers and such, it is a good idea to specify the command-line option <code>-A</code> to autodetect the address offset. Otherwise the program will simply fill any unused addresses, starting from 0, with zero bytes, which may total mega- or even gigabytes.</p>
<h1>Utilities </h1>
<p>Four additional utilities are provided to help working with ROM images:</p>
<ul>
<li><code>split16bit</code> – splits a 16-bit ROM binary into two 8-bit halves</li>
<li><code>merge16bit</code> – merges two 8-bit ROM binary halves into a single 16-bit file</li>
<li><code>split32bit</code> – splits a 32-bit ROM binary into four 8-bit parts</li>
<li><code>merge32bit</code> – merges four 8-bit ROM binary parts into a single 32-bit file</li>
</ul>
<p>Both 16-bit utilities take the filenames of the high and low halves with the arguments <code>-l&#160;low.bin</code> and <code>-h&#160;high.bin</code>, respectively. The bytes are in little endian order, i.e., the one with the lowest address is the "low" half. </p><pre class="fragment"># Split 16bit.bin into low.bin and high.bin:
split16bit -i 16bit.bin -l low.bin -h high.bin

# Merge low.bin and high.bin into 16bit.bin:
merge16bit -o 16bit.bin -l low.bin -h high.bin
</pre><p> Both 32-bit utilities take the filenames of the four 8-bit files with the arguments <code>-0</code>, <code>-1</code>, <code>-2</code>, and <code>-3</code>, with byte 0 being the one with the lowest address, i.e., the bytes are in little endian order. </p><pre class="fragment"># Split 32bit.bin into a.bin, b.bin, c.bin, and d.bin
split32bit -i 32bit.bin -0 a.bin -1 b.bin -2 c.bin -3 d.bin

# Merge a.bin, b.bin, c.bin, and d.bin into 32bit.bin
merge32bit -o 32bit.bin -0 a.bin -1 b.bin -2 c.bin -3 d.bin
</pre><p> These utilities have nothing to with IHEX as such, but they are so small that it didn't seem worth the bother to release them separately. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
